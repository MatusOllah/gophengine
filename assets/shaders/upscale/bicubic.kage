// Kage implementation of a 4x4 bicubic filter based on a Shadertoy shader: https://www.shadertoy.com/view/4df3Dn

//kage:unit pixels

package main

// 4x4 bicubic filter using 4 bilinear texture lookups 
// See GPU Gems 2: "Fast Third-Order Texture Filtering", Sigg & Hadwiger:
// http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter20.html

// w0, w1, w2, and w3 are the four cubic B-spline basis functions
func w0(a float) float {
    return (1.0/6.0)*(a*(a*(-a + 3.0) - 3.0) + 1.0)
}

func w1(a float) float {
    return (1.0/6.0)*(a*a*(3.0*a - 6.0) + 4.0)
}

func w2(a float) float {
    return (1.0/6.0)*(a*(a*(-3.0*a + 3.0) + 3.0) + 1.0)
}

func w3(a float) float {
    return (1.0/6.0)*(a*a*a)
}

// g0 and g1 are the two amplitude functions
func g0(a float) float {
    return w0(a) + w1(a)
}

func g1(a float) float {
    return w2(a) + w3(a)
}
// h0 and h1 are the two offset functions
func h0(a float) float {
    return -1.0 + w1(a) / (w0(a) + w1(a))
}

func h1(a float) float {
    return 1.0 + w3(a) / (w2(a) + w3(a))
}

func texture_bicubic(uv vec2, texelSize vec4) vec4 {
    uv = uv*texelSize.zw + 0.5
    iuv := floor(uv)
    fuv := fract(uv)

    g0x := g0(fuv.x)
    g1x := g1(fuv.x)
    h0x := h0(fuv.x)
    h1x := h1(fuv.x)
    h0y := h0(fuv.y)
    h1y := h1(fuv.y)

    p0 := (vec2(iuv.x + h0x, iuv.y + h0y) - 0.5) * texelSize.xy
    p1 := (vec2(iuv.x + h1x, iuv.y + h0y) - 0.5) * texelSize.xy
    p2 := (vec2(iuv.x + h0x, iuv.y + h1y) - 0.5) * texelSize.xy
    p3 := (vec2(iuv.x + h1x, iuv.y + h1y) - 0.5) * texelSize.xy

    return g0(fuv.y) * (g0x * imageSrc0UnsafeAt(p0)  +
                        g1x * imageSrc0UnsafeAt(p1)) +
           g1(fuv.y) * (g0x * imageSrc0UnsafeAt(p2)  +
                        g1x * imageSrc0UnsafeAt(p3))
}

func Fragment(_ vec4, srcPos vec2, _ vec4) vec4 {
    p := srcPos.xy
    uv := p * 1

    // bicubic
    texelSize := vec4(1.0 / imageSrc0Size().xy, imageSrc0Size().xy)
    colB := texture_bicubic(uv, texelSize).xyz

    return vec4(colB, 1.0)
}
